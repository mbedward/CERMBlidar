#' Calculate quantiles of stratum vegetation cover based on LiDAR point counts
#'
#' This function takes a multi-band raster of LiDAR point counts for ground
#' level and vegetation strata, arranged in increasing height order (i.e. ground
#' is band 1), and returns a raster of vegetation cover estimates for strata.
#' Estimates are based on a Bayesian approach, where the detection of stratum
#' vegetation is viewed as a binomial sampling process. LiDAR points (i.e.
#' discrete returns) from a stratum are treated as 'successes' while points from
#' ground level and any lower strata are 'failures'. Under this model, the
#' binomial probability of success is an estimator of vegetation cover, while
#' the degree of certainty about the estimate will depend on the LiDAR point
#' density. Selected quantiles for estimated cover are returned as raster bands
#' for each stratum. The default is to calculate median cover and the central
#' 90\% bounds (5\%, 50\% and 95\% quantiles) for each stratum. Optionally, the
#' maximum likelihood estimate of mean cover can also be returned.
#'
#' If we view the detection of vegetation within a stratum via discrete LiDAR
#' returns as a binomial sampling process, then we can make use of the
#' relationship between the binomial and beta distributions. For a given pixel,
#' if we have \code{n} returns from vegetation within a stratum out of a total
#' of \code{N} returns from that stratum or lower (including ground level), then
#' the distribution of the possible vegetation cover values for the stratum that
#' could result in the observed points counts will follow a beta distribution.
#' For the baseline no-data case (ie. no LiDAR returns from the stratum or
#' below, perhaps because higher strata blocked all LiDAR pulses), it is
#' reasonable to depict the possible cover distribution as uniform between 0 and
#' 1, i.e. with no data we have no reason to prefer any cover value over any
#' other. This baseline can be represented as a \code{beta(1, 1)} distribution
#' which, for quantile calculations, we refer to as the \emph{Bayesian prior
#' distribution} of cover values. Most of the time this is probably what you
#' want to use. We use the LiDAR data within a pixel to \emph{update} our
#' expectation of stratum cover from the flat prior \code{beta(1, 1)}
#' distribution to a \code{beta(1+n, 1+n-N)} distribution. We can then summarize
#' this distribution via selected quantiles which can be output as raster
#' layers.
#'
#' Sometimes, it might be preferable to adopt something other than a uniform
#' prior expectation for vegetation cover. For example, from previous studies
#' and/or expert knowledge we might expect that tree canopy cover will typically
#' be around 30\%, relative to the pixel size being used for mapping, with a
#' certain degree of variation around this value. In this case, a beta
#' distribution can be chosen to represent this expectation (e.g.
#' \code{beta(2,5)}) and specified for the stratum using the \code{beta_prior}
#' argument. See examples below.
#'
#' In addition to quantiles of stratum vegetation cover, this function can be
#' used to calculate the simpler maximum likelihood estimate of mean cover
#' (MLE), equivalent to the value returned by the deprecated function
#' \code{get_stratum_cover}. The MLE is the ratio of the number of LiDAR points
#' returned from within the stratum height range to the total number of points
#' returned between ground level and the top of the stratum. This value
#' corresponds to the mode of the beta distribution used to calculate quantiles,
#' assuming that the default \code{beta(1,1)} prior distribution has been
#' specified.
#'
#'
#' @param rcounts A raster object with a band of point count data for each
#'   vegetation stratum plus a band for the ground layer. Normally, this will be
#'   a \code{terra} package \code{SpatRaster} object generated by function
#'   \code{get_stratum_counts()}, but it may also be a \code{RasterStack} or
#'   \code{RasterBrick} (\code{raster} package) object. \strong{Important:} the
#'   bands must be arranged in increasing height order, i.e. ground layer, then
#'   understorey layer(s), then overstorey layer(s).
#'
#' @param probs A numeric vector of one or more probability values specifying
#'   the quantiles of vegetation cover.  The default \code{c(0.05, 0.5, 0.95)}
#'   returns quantiles for the median and the central 90\% interval. To suppress
#'   quantile calculations and only return the maximum likelihood estimate of
#'   mean cover, set this argument to \code{NULL, NA} or an empty vector, and
#'   set argument \code{mle=TRUE}.
#'
#' @param mle A logical value specifying whether the maximum likelihood estimate
#'   (MLE) of mean cover should be returned in addition to any specified cover
#'   quantiles. The MLE is the same value as that returned by the deprecated
#'   function \code{get_stratum_cover}. Set to \code{FALSE} (default) if the MLE
#'   is not required; or to \code{TRUE} to return the MLE in addition to any
#'   quantiles specified via the \code{probs} argument. See Details for
#'   information.
#'
#' @param backgroundNA Controls what pixel value should be returned for a
#'   stratum when there are no LiDAR points for the stratum, any lower strata or
#'   ground. If set to \code{TRUE}, such cases will have missing (\code{NA})
#'   pixel values for all quantile layers for the stratum. If \code{FALSE} (the
#'   default), pixel values will be calculated as quantiles of the prior beta
#'   distribution. Note that if maximum likelihood mean cover estimates are
#'   specified (via \code{mle=TRUE}) these will always be \code{NA} for any
#'   pixels without LiDAR data.
#'
#' @param beta_prior (\strong{Expert use only!}) Either a numeric vector
#'   of two values defining the prior beta distribution to use for all strata,
#'   or a named list of two-element numeric vectors where the element names
#'   match (case-insensitive) layer names for vegetation strata in the input
#'   point count raster. The default is \code{c(1,1)} for a \code{beta(1,1)}
#'   distribution which is equivalent to a uniform distribution on the (0,1)
#'   interval for all strata. This is probably what you want unless (a) you
#'   really know what you are doing and (b) there are particular reasons, i.e.
#'   previous studies or expert knowledge, to expect cover values for one or
#'   more strata to follow alternative distributions. See the Details section
#'   for further explanation.
#'
#' @return A \code{SpatRast} (\code{terra} package) raster object with a layer
#'   for each requested quantile within each stratum. For example, calculating
#'   the default median plus 90\% bounds (0.05 and 0.95 quantiles) for 5
#'   vegetation strata would return a raster object with 15 layers. Layers are
#'   arranged by stratum, then by quantile. Layer names have the form
#'   \code{stratum_q_prob}, e.g. \code{'TallShrub_q_0.5'} for the median (50\%)
#'   quantile. If the maximum likelihood cover estimate has been requested
#'   (\code{mle=TRUE}), this will appear before any quantile layers for each
#'   stratum with a name of the form \code{stratum_mle}.
#'
#' @export
#'
get_cover_quantiles <- function(rcounts,
                                probs = c(0.05, 0.5, 0.95),
                                mle = FALSE,
                                backgroundNA = FALSE,
                                beta_prior = c(1, 1)) {

  rcounts <- .as_spat_raster(rcounts)
  .sanity_check_point_counts(rcounts)

  # Check if quantiles are not required
  if (is.null(probs) || is.na(probs[1])) {
    probs <- numeric()
  } else {
    if (!is.numeric(probs)) stop("Argument probs should be a numeric vector or NULL")
    if (!all(probs > 0 & probs < 1)) stop("Requested quantile (probs) must all be >0 and <1")

    probs <- sort(unique(probs))
  }

  # Check that at least one of quantiles or MLE has been requested
  mle <- .as_boolean(mle)
  if (!mle && length(probs) == 0) stop("At least one of quantiles or max likelihood estimate must be specified")

  backgroundNA <- .as_boolean(backgroundNA)

  nbands <- terra::nlyr(rcounts)
  if (nbands < 2) {
    msg <- glue::glue("The point count raster must have at least two layers
                       with the first layer being ground level point counts and
                       subsequent layers being stratum point counts in order of
                       increasing height.")

    stop(msg)
  }

  # Check the beta_prior argument
  .sanity_check_beta_prior(beta_prior, nbands)

  # Convert the beta_prior argument to matrix form.
  if (is.numeric(beta_prior)) {
    beta_prior <- lapply(2:nbands, function(...) beta_prior)
  }
  beta_prior <- do.call(rbind, beta_prior)

  # Worker function for cover calculations
  fn <- function(x, istratum) {
    nout <- mle + length(probs)
    res <- numeric(nout)
    k <- 1

    prior_params <- beta_prior[istratum, ]

    if (mle) {
      res[1] <- ifelse(x[2] == 0, NA, x[1] / x[2])
      k <- 2
    }
    if (length(probs) > 0) {
      res[k:nout] <- qbeta(probs,
                           shape1 = prior_params[1] + x[1],
                           shape2 = prior_params[2] + x[2] - x[1])
    }
    res
  }

  # Initialize a raster of total point counts with the ground layer
  rsum <- terra::subset(rcounts, 1)

  # For each veg stratum band:
  #   - increment total point count
  #   - call worker function to calculate quantiles and/or MLE
  #
  res <- lapply(2:nbands, function(iband) {
    rband <- terra::subset(rcounts, iband)
    rsum <<- rsum + rband

    rres <- terra::app(c(rband, rsum), fn, istratum=iband-1)

    # Set names for result layer(s) for this stratum
    nout_layers <- mle + length(probs)
    k <- 1
    if (mle) {
      names(rres)[1] <- sprintf("%s_mle", names(rcounts)[iband])
      k <- 2
    }
    if (length(probs) > 0) {
      names(rres)[k:nout_layers] <- sprintf("%s_q_%g", names(rcounts)[iband], probs)
    }

    rres
  })

  # Merge list of result layers into a single SpatRaster
  # and return
  terra::rast(res)
}


#' Bayesian credible interval for difference in cover values
#'
#' This function estimates vegetation cover difference based on two point count
#' rasters, e.g. as returned by \code{\link{get_stratum_counts}}. Each raster
#' should have two or more bands, with the first band representing ground point
#' counts and subsequent bands representing point counts for vegetation strata.
#' Typical usage is where the point count rasters are derived from LiDAR data
#' for the same area at two different times, and we wish to report a bounded
#' estimate of vegetation cover difference between the two times, where the bounds
#' take into account the point density of the LiDAR data at each of the two
#' times. Difference results are summarized as selected quantiles, specified via
#' the \code{probs} argument. These quantiles are calculated using the function
#' \code{\link[tolerance]{qdiffprop}} from the \code{tolerance} package.
#'
#' To illustrate the method, consider a single horizontal pixel location in each
#' of the point count rasters \code{r0} and \code{r1}, where we want to estimate
#' the vegetation cover difference, i.e. the change in cover for r1 compared to
#' r0, for a given stratum \code{s}. A naive mean cover estimate for the pixel
#' in each raster could be calculated as the ratio of the stratum point count,
#' i.e. number of LiDAR points from within the height range of the stratum, to
#' the total number of LiDAR points from ground level to the upper height of the
#' stratum. This is the calculation performed by function
#' \code{\link{get_stratum_cover}}. An estimate of cover difference is then
#' simply the cover derived from \code{r0} minus that derived from \code{r1}.
#' However, a problem with this approach is that it gives no indication of how
#' much certainty we can have in either the mean cover estimates, or the
#' estimate of difference, since it ignores the number of LiDAR points in each
#' set. A cover value of 25 percent based on 4 stratum points out of 16 total points
#' represents a much less precise estimate than one based on 20 stratum points
#' out of 80 total points.
#'
#' A more robust alternative is to consider the distribution of true stratum
#' cover values that could have generated the observed point counts. If we
#' assume, hopefully without departing from reality too much, that LiDAR points
#' are located randomly within the pixel, we can treat the detection of
#' vegetation as a binomial sampling process. The count of stratum points is
#' taken as a draw from a \code{binomial(n, p)} distribution where \code{n} is
#' total number of LiDAR points from ground level to the top of the stratum; and
#' \code{p} is the probability of a point being a return from vegetation. Under
#' this model, \code{p} represents the actual projected foliage cover and our
#' interest lies in the distribution of \code{p} values that feasibly result in
#' the observed point counts. This will follow a beta distribution with
#' parameters: \code{shape1 = 1 + stratum point count} and
#' \code{shape2 = 1 + total point count - stratum point count}.
#' The distribution of vegetation cover change can then be derived as the
#' difference between the beta distribution based on raster \code{r1} and that based
#' on raster \code{r0}.
#'
#' @param r0 First point count raster (e.g. earlier time). This should be a
#'   raster with integer cell values.
#'
#' @param r1 Second point count raster (e.g. later time). This should be a
#'   raster with integer cell values and the same number of bands as raster
#'   \code{r0}.
#'
#' @param probs Quantiles for cover difference. The default is to return
#'   quantiles for the median and the 90\% credible interval.
#'
#'
#' @export
#'
get_cover_difference <- function(r0, r1, probs = c(0.05, 0.5, 0.95)) {

  r0 <- .as_spat_raster(r0)
  r1 <- .as_spat_raster(r1)

  # Point count rasters should both have integer cell values and the same number of bands (> 1)
  nbands <- terra::nlyr(r0)
  if (nbands < 2) {
    stop("Both point count rasters must have at least 2 bands")
  }

  n1 <- terra::nlyr(r1)
  if (n1 != nbands) {
    msg <- glue::glue("Point count rasters differ in number of bands: {nbands} versus {n1}")
    stop(msg)
  }

  .sanity_check_point_counts(r0, label = "raster r0")
  .sanity_check_point_counts(r1, label = "raster r1")

  rsum0 <- terra::subset(r0, 1)
  rsum1 <- terra::subset(r1, 1)

  fn <- function(r) {
    tolerance::qdiffprop(0.5, k1 = r[1], k2 = r[2], n1 = r[3], n2 = r[4])
  }

  res <- lapply(2:nbands, function(iband) {
    rband0 <- terra::subset(r0, iband)
    rsum0 <<- rsum0 + rband0

    rband1 <- terra::subset(r1, iband)
    rsum1 <<- rsum1 + rband1

    r <- c(rband0, rband1, rsum0, rsum1)
    rx0 <- terra::app(r, fn)

    names(rx0) <- sprintf("%s_q_%g", names(r0)[iband], probs)

  })

  # Merge list of result layers into a single SpatRaster
  # and return
  terra::rast(res)
}


# Private helper to check that a raster looks like valid point count data.
# Input must be a terra::SpatRaster object.
#
.sanity_check_point_counts <- function(r, label = NULL) {
  if (is.null(label)) label <- deparse(substitute(r))

  if (!inherits(r, "SpatRaster")) stop(label, " must be a terra package SpatRaster object")

  if (!all(terra::hasMinMax(r))) terra::setMinMax(r)
  lims <- t( terra::minmax(r) ) # bands as rows; min,max as cols

  # Check sane minimum values
  if (any(lims[,1] < 0)) stop(label, " has minimum value less than zero in one or more bands")

  # Check values are integers
  x <- as.vector(lims)
  if (any(x - as.integer(x) != 0)) stop(label, " has non-integer values in one or more bands")
}


# Private helper function to check that a vector is a valid set of parameters
# for a beta prior distribution.
#
# x - numeric vector or list of number vectors
# nlayers - number of layers in the point counts raster being processed
#   by get_cover_quantiles()
#
.sanity_check_beta_prior <- function(x, nlayers) {
  nm <- deparse(substitute(x))

  .check_vector <- function(v, index = NULL) {
    if (!is.null(index)) nm <- paste(nm, "element", index)
    if (length(v) != 2) stop(nm, " should be a numeric vector with two values")
    if (!all(v > 0)) stop("Both values in ", nm, " must be greater than zero")
  }

  if (is.numeric(x)) {
    .check_vector(x)

  } else if (is.list(x)) {
    if (length(x) != nlayers - 1) {
      msg <- glue::glue(
        "The list of beta prior parameters '{nm}' has {length(x)} elements.
        Expected {nlayers - 1} elements corresponding to the {nlayers - 1} non-ground layers
        in the point counts raster")
      stop(msg)
    }

    for (i in seq_along(x)) .check_vector(x[[i]], i)

  } else {
    stop(nm, " must be a two-element numeric vector or a list of vectors")
  }
}

