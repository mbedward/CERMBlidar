#' Calculate selected quantiles for stratum vegetation cover
#'
#' This function is an alternative to the simple \code{get_stratum_cover}
#' function that takes into account the LiDAR point density. It treats the
#' estimation of stratum cover as a binomial process, where stratum points are
#' 'successes' while points from ground level and any lower strata are
#' 'failures'. Based on this, selected quantiles for the probability of success,
#' which is equivalent to vegetation cover, can be calculated from a beta
#' distribution. This is essentially a Bayesian statistical approach to cover
#' estimation. Compared to the simple maximum likelihood calculation performed
#' by the \code{get_stratum_cover} function, it provides a readily interpretable
#' measure of precision for vegetation cover estimates.
#'
#' If we view the detection of vegetation within a stratum via discrete LiDAR returns
#' as a binomial sampling process, then we can make use of the relationship
#' between the binomial and beta distributions. For a given pixel, if we have
#' \code{n} returns from vegetation within a stratum out of a total of \code{N} returns
#' from that stratum or lower (including ground level), then the distribution of
#' the possible vegetation cover values for the stratum that could result in the
#' observed points counts will follow a beta distribution. For the baseline
#' no-data case (ie. no LiDAR returns from the stratum or below, perhaps because
#' higher strata blocked all LiDAR pulses), it is reasonable to depict the
#' possible cover distribution as uniform between 0 and 1, i.e. with no data we have no
#' reason to prefer any cover value over any other. This baseline can be
#' represented as a \code{beta(1, 1)} distribution which, for quantile
#' calculations, we refer to as the \emph{Bayesian prior distribution} of cover
#' values. Most of the time this is probably what you want to use. We use the
#' LiDAR data within a pixel to \emph{update} our expectation of stratum cover
#' from the flat prior \code{beta(1, 1)} distribution to a \code{beta(1+n,
#' 1+n-N)} distribution. We can then summarize this distribution via selected
#' quantiles which can be output as raster layers.
#'
#' Sometimes, it might be preferable to adopt something other than a uniform
#' prior expectation for vegetation cover. For example, from previous studies
#' and/or expert knowledge we might expect that tree canopy cover will typically
#' be around 30\%, relative to the pixel size being used for mapping, with a
#' certain degree of variation around this value. In this case, a beta
#' distribution can be chosen to represent this expectation (e.g.
#' \code{beta(2,5)}) and specified for the stratum using the \code{beta_prior}
#' argument. See examples below.
#'
#' In addition to quantiles of stratum vegetation cover, this function can be
#' used to calculate the simpler maximum likelihood estimate of mean cover
#' (MLE), equivalent to the value returned by the deprecated function
#' \code{get_stratum_cover}. The MLE is the ratio of the number of LiDAR points
#' returned from within the stratum height range to the total number of points
#' returned between ground level and the top of the stratum. This value
#' corresponds to the mode of the beta distribution used to calculate quantiles,
#' assuming that the default \code{beta(1,1)} prior distribution has been
#' specified.
#'
#'
#' @param rcounts A raster object with a band of point count data for each
#'   vegetation stratum plus a band for the ground layer. Normally, this will be
#'   a \code{terra} package \code{SpatRaster} object generated by function
#'   \code{get_stratum_counts()}, but it may also be a \code{RasterStack} or
#'   \code{RasterBrick} (\code{raster} package) object.
#'
#' @param probs A numeric vector of one or more probability values specifying
#'   the quantiles of vegetation cover.  The default \code{c(0.05, 0.5, 0.95)}
#'   returns quantiles for the median and the central 90\% interval. To suppress
#'   quantile calculations and only return the maximum likelihood estimate of
#'   mean cover, set this argument to \code{NULL, NA} or an empty vector, and
#'   set argument \code{mle=TRUE}.
#'
#' @param mle A logical value specifying whether the maximum likelihood estimate
#'   (MLE) of mean cover should be returned in addition to any specified cover
#'   quantiles. The MLE is the same value as that returned by the deprecated
#'   function \code{get_stratum_cover}. Set to \code{FALSE} (default) if the MLE
#'   is not required; or to \code{TRUE} to return the MLE in addition to any
#'   quantiles specified via the \code{probs} argument. See Details for
#'   information.
#'
#' @param backgroundNA Controls what pixel value should be returned for a
#'   stratum when there are no LiDAR points for the stratum, any lower strata or
#'   ground. If set to \code{TRUE}, such cases will have missing (\code{NA})
#'   pixel values for all quantile layers for the stratum. If \code{FALSE} (the
#'   default), pixel values will be calculated as quantiles of the prior beta
#'   distribution. Note that if maximum likelihood mean cover estimates are
#'   specified (via \code{mle=TRUE}) these will always be \code{NA} for any
#'   pixels without LiDAR data.
#'
#' @param beta_prior (\strong{Expert use only!}) Either a numeric vector
#'   of two values defining the prior beta distribution to use for all strata,
#'   or a named list of two-element numeric vectors where the element names
#'   match (case-insensitive) layer names for vegetation strata in the input
#'   point count raster. The default is \code{c(1,1)} for a \code{beta(1,1)}
#'   distribution which is equivalent to a uniform distribution on the (0,1)
#'   interval for all strata. This is probably what you want unless (a) you
#'   really know what you are doing and (b) there are particular reasons, i.e.
#'   previous studies or expert knowledge, to expect cover values for one or
#'   more strata to follow alternative distributions. See the Details section
#'   for further explanation.
#'
#' @return A \code{SpatRast} (\code{terra} package) raster object with a layer
#'   for each requested quantile within each stratum. For example, calculating
#'   the default median plus 90\% bounds (0.05 and 0.95 quantiles) for 5 vegetation
#'   strata would return a raster object with 15 layers. Layer names have the
#'   form \code{stratum_q_prob}, e.g. \code{'TallShrub_q_0.5'} for the median
#'   (50\%) quantile.
#'
#' @export
#'
get_cover_quantiles <- function(rcounts,
                                probs = c(0.05, 0.5, 0.95),
                                mle = FALSE,
                                backgroundNA = FALSE,
                                beta_prior = c(1, 1)) {

  rcounts <- .as_spat_raster(rcounts)
  .sanity_check_point_counts(rcounts)

  # Check if quantiles are not required
  if (is.null(probs) || is.na(probs[1])) {
    probs <- numeric()
  } else {
    if (!is.numeric(probs)) stop("Argument probs should be a numeric vector or NULL")
    if (!all(probs > 0 & probs < 1)) stop("Requested quantile (probs) must all be >0 and <1")

    probs <- sort(unique(probs))
  }

  # Check that at least one of quantiles or MLE has been requested
  mle <- .as_boolean(mle)
  if (!mle && length(probs) == 0) stop("At least one of quantiles or max likelihood estimate must be specified")

  backgroundNA <- .as_boolean(backgroundNA)

  nbands <- terra::nlyr(rcounts)
  if (nbands < 2) {
    msg <- glue::glue("The point count raster must have at least two layers
                       with the first layer being ground level point counts and
                       subsequent layers being stratum point counts in order of
                       increasing height.")

    stop(msg)
  }

  # Check the beta_prior argument
  .sanity_check_beta_prior(beta_prior, nbands)

  # Convert the beta_prior argument to matrix form.
  if (is.numeric(beta_prior)) {
    beta_prior <- lapply(2:nbands, function(...) beta_prior)
  }
  beta_prior <- do.call(rbind, beta_prior)

  rsum <- terra::subset(rcounts, 1)

  fn <- function(x, istratum) {
    nout <- mle + length(probs)
    res <- numeric(nout)
    k <- 1

    prior_params <- beta_prior[[istratum]]

    if (mle) {
      res[1] <- ifelse(x[2] == 0, NA, x[1] / x[2])
      k <- 2
    }
    if (length(probs) > 0) {
      res[k:nout] <- qbeta(probs,
                           shape1 = prior_params[1] + x[1],
                           shape2 = prior_params[2] + x[2] - x[1])
    }
    res
  }

  res <- lapply(2:nbands, function(iband) {
    rband <- terra::subset(rcounts, iband)
    rsum <<- rsum + rband

    rres <- terra::app(c(rband, rsum), fn, istratum=iband-1)

    nout_layers <- mle + length(probs)
    k <- 1
    if (mle) {
      names(rres)[1] <- sprintf("%s_mle", names(rcounts)[iband])
      k <- 2
    }
    if (length(probs) > 0) {
      names(rres)[k:nout_layers] <- sprintf("%s_q_%g", names(rcounts)[iband], probs)
    }

    rres
  })

  # Merge list of result layers into a single SpatRaster
  # and return
  terra::rast(res)
}


# Private helper to check that a raster looks like valid point count data.
# Input must be a terra::SpatRaster object.
#
.sanity_check_point_counts <- function(r, label = NULL) {
  if (is.null(label)) label <- deparse(substitute(r))

  if (!inherits(r, "SpatRaster")) stop(label, " must be a terra package SpatRaster object")

  if (!all(terra::hasMinMax(r))) terra::setMinMax(r)
  lims <- t( terra::minmax(r) ) # bands as rows; min,max as cols

  # Check sane minimum values
  if (any(lims[,1] < 0)) stop(label, " has minimum value less than zero in one or more bands")

  # Check values are integers
  x <- as.vector(lims)
  if (any(x - as.integer(x) != 0)) stop(label, " has non-integer values in one or more bands")
}


# Private helper function to check that a vector is a valid set of parameters
# for a beta prior distribution.
#
# x - numeric vector or list of number vectors
# nlayers - number of layers in the point counts raster being processed
#   by get_cover_quantiles()
#
.sanity_check_beta_prior <- function(x, nlayers) {
  nm <- deparse(substitute(x))

  .check_vector <- function(v, index = NULL) {
    if (!is.null(index)) nm <- paste(nm, "element", index)
    if (length(v) != 2) stop(nm, " should be a numeric vector with two values")
    if (!all(v > 0)) stop("Both values in ", nm, " must be greater than zero")
  }

  if (is.numeric(x)) {
    .check_vector(x)

  } else if (is.list(x)) {
    if (length(x) != nlayers - 1) {
      msg <- glue::glue(
        "The list of beta prior parameters '{nm}' has {length(x)} elements.
        Expected {nlayers - 1} elements corresponding to the {nlayers - 1} non-ground layers
        in the point counts raster")
      stop(msg)
    }

    for (i in seq_along(x)) .check_vector(x[[i]], i)

  } else {
    stop(nm, " must be a two-element numeric vector or a list of vectors")
  }
}

