#' Calculate quantiles of stratum vegetation cover based on LiDAR point counts
#'
#' This function takes a multi-band raster of LiDAR point counts for ground
#' level and vegetation strata, arranged in increasing height order (i.e. ground
#' is band 1), and returns a raster of vegetation cover estimates for strata.
#' Estimates are based on a Bayesian approach, where the detection of stratum
#' vegetation is viewed as a binomial sampling process. LiDAR points (i.e.
#' discrete returns) from a stratum are treated as 'successes' while points from
#' ground level and any lower strata are 'failures'. Under this model, the
#' binomial probability of success is an estimator of vegetation cover, while
#' the degree of certainty about the estimate will depend on the LiDAR point
#' density. Selected quantiles for estimated cover are returned as raster bands
#' for each stratum. The default is to calculate median cover and the central
#' 90\% bounds (5\%, 50\% and 95\% quantiles) for each stratum. Optionally, the
#' maximum likelihood estimate of mean cover can also be returned.
#'
#' If we view the detection of vegetation within a stratum via discrete LiDAR
#' returns as a binomial sampling process, then we can make use of the
#' relationship between the binomial and beta distributions. For a given pixel,
#' if we have \code{n} returns from vegetation within a stratum out of a total
#' of \code{N} returns from that stratum or lower (including ground level), then
#' the distribution of the possible vegetation cover values for the stratum that
#' could result in the observed points counts will follow a beta distribution.
#' For the baseline no-data case (ie. no LiDAR returns from the stratum or
#' below, perhaps because higher strata blocked all LiDAR pulses), it is
#' reasonable to depict the possible cover distribution as uniform between 0 and
#' 1, i.e. with no data we have no reason to prefer any cover value over any
#' other. This baseline can be represented as a \code{beta(1, 1)} distribution
#' which, for quantile calculations, we refer to as the \emph{Bayesian prior
#' distribution} of cover values. Most of the time this is probably what you
#' want to use. We use the LiDAR data within a pixel to \emph{update} our
#' expectation of stratum cover from the flat prior \code{beta(1, 1)}
#' distribution to a \code{beta(1+n, 1+n-N)} distribution. We can then summarize
#' this distribution via selected quantiles which can be output as raster
#' layers.
#'
#' Sometimes, it might be preferable to adopt something other than a uniform
#' prior expectation for vegetation cover. For example, from previous studies
#' and/or expert knowledge we might expect that tree canopy cover will typically
#' be around 30\%, relative to the pixel size being used for mapping, with a
#' certain degree of variation around this value. In this case, a beta
#' distribution can be chosen to represent this expectation (e.g.
#' \code{beta(2,5)}) and specified for the stratum using the \code{beta_prior}
#' argument. See examples below.
#'
#' In addition to quantiles of stratum vegetation cover, this function can be
#' used to calculate the simpler maximum likelihood estimate of mean cover
#' (MLE), equivalent to the value returned by the deprecated function
#' \code{get_stratum_cover}. The MLE is the ratio of the number of LiDAR points
#' returned from within the stratum height range to the total number of points
#' returned between ground level and the top of the stratum. This value
#' corresponds to the mode of the beta distribution used to calculate quantiles,
#' assuming that the default \code{beta(1,1)} prior distribution has been
#' specified.
#'
#'
#' @param rcounts A raster object with a band of point count data for each
#'   vegetation stratum plus a band for the ground layer. Normally, this will be
#'   a \code{terra} package \code{SpatRaster} object generated by function
#'   \code{get_stratum_counts()}, but it may also be a \code{RasterStack} or
#'   \code{RasterBrick} (\code{raster} package) object. \strong{Important:} the
#'   bands must be arranged in increasing height order, i.e. ground layer, then
#'   understorey layer(s), then overstorey layer(s).
#'
#' @param probs A numeric vector of one or more probability values specifying
#'   the quantiles of vegetation cover.  The default \code{c(0.05, 0.5, 0.95)}
#'   returns quantiles for the median and the central 90\% interval. To suppress
#'   quantile calculations and only return the maximum likelihood estimate of
#'   mean cover, set this argument to \code{NULL, NA} or an empty vector, and
#'   set argument \code{mle=TRUE}.
#'
#' @param mle A logical value specifying whether the maximum likelihood estimate
#'   (MLE) of mean cover should be returned in addition to any specified cover
#'   quantiles. The MLE is the same value as that returned by the deprecated
#'   function \code{get_stratum_cover}. Set to \code{FALSE} (default) if the MLE
#'   is not required; or to \code{TRUE} to return the MLE in addition to any
#'   quantiles specified via the \code{probs} argument. See Details for
#'   information.
#'
#' @param backgroundNA Controls what pixel value should be returned for a
#'   stratum when there are no LiDAR points for the stratum, any lower strata or
#'   ground. If set to \code{TRUE}, such cases will have missing (\code{NA})
#'   pixel values for all quantile layers for the stratum. If \code{FALSE} (the
#'   default), pixel values will be calculated as quantiles of the prior beta
#'   distribution. Note that if maximum likelihood mean cover estimates are
#'   specified (via \code{mle=TRUE}) these will always be \code{NA} for any
#'   pixels without LiDAR data.
#'
#' @param beta_prior (\strong{Expert use only!}) Either a numeric vector
#'   of two values defining the prior beta distribution to use for all strata,
#'   or a named list of two-element numeric vectors where the element names
#'   match (case-insensitive) layer names for vegetation strata in the input
#'   point count raster. The default is \code{c(1,1)} for a \code{beta(1,1)}
#'   distribution which is equivalent to a uniform distribution on the (0,1)
#'   interval for all strata. This is probably what you want unless (a) you
#'   really know what you are doing and (b) there are particular reasons, i.e.
#'   previous studies or expert knowledge, to expect cover values for one or
#'   more strata to follow alternative distributions. See the Details section
#'   for further explanation.
#'
#' @return A \code{SpatRast} (\code{terra} package) raster object with a layer
#'   for each requested quantile within each stratum. For example, calculating
#'   the default median plus 90\% bounds (0.05 and 0.95 quantiles) for 5
#'   vegetation strata would return a raster object with 15 layers. Layers are
#'   arranged by stratum, then by quantile. Layer names have the form
#'   \code{stratum_q_prob}, e.g. \code{'TallShrub_q_0.5'} for the median (50\%)
#'   quantile. If the maximum likelihood cover estimate has been requested
#'   (\code{mle=TRUE}), this will appear before any quantile layers for each
#'   stratum with a name of the form \code{stratum_mle}.
#'
#' @export
#'
get_cover_quantiles <- function(rcounts,
                                probs = c(0.05, 0.5, 0.95),
                                mle = FALSE,
                                backgroundNA = FALSE,
                                beta_prior = c(1, 1)) {

  rcounts <- .as_spat_raster(rcounts)
  .sanity_check_point_counts(rcounts)

  # Check if quantiles are not required
  if (is.null(probs) || is.na(probs[1])) {
    probs <- numeric()
  } else {
    if (!is.numeric(probs)) stop("Argument probs should be a numeric vector or NULL")
    if (!all(probs > 0 & probs < 1)) stop("Requested quantile (probs) must all be >0 and <1")

    probs <- sort(unique(probs))
  }

  # Check that at least one of quantiles or MLE has been requested
  mle <- .as_boolean(mle)
  if (!mle && length(probs) == 0) stop("At least one of quantiles or max likelihood estimate must be specified")

  backgroundNA <- .as_boolean(backgroundNA)

  nbands <- terra::nlyr(rcounts)
  if (nbands < 2) {
    msg <- glue::glue("The point count raster must have at least two layers
                       with the first layer being ground level point counts and
                       subsequent layers being stratum point counts in order of
                       increasing height.")

    stop(msg)
  }

  # Check the beta_prior argument
  .sanity_check_beta_prior(beta_prior, nbands)

  # Convert the beta_prior argument to matrix form.
  if (is.numeric(beta_prior)) {
    beta_prior <- lapply(2:nbands, function(...) beta_prior)
  }
  beta_prior <- do.call(rbind, beta_prior)

  # Worker function for cover calculations
  fn <- function(x, istratum) {
    nout <- mle + length(probs)
    res <- numeric(nout)
    k <- 1

    prior_params <- beta_prior[istratum, ]

    if (mle) {
      res[1] <- ifelse(x[2] == 0, NA, x[1] / x[2])
      k <- 2
    }
    if (length(probs) > 0) {
      res[k:nout] <- qbeta(probs,
                           shape1 = prior_params[1] + x[1],
                           shape2 = prior_params[2] + x[2] - x[1])
    }
    res
  }

  # Initialize a raster of total point counts with the ground layer
  rsum <- terra::subset(rcounts, 1)

  # For each veg stratum band:
  #   - increment total point count
  #   - call worker function to calculate quantiles and/or MLE
  #
  res <- lapply(2:nbands, function(iband) {
    rband <- terra::subset(rcounts, iband)
    rsum <<- rsum + rband

    rres <- terra::app(c(rband, rsum), fn, istratum=iband-1)

    # Set names for result layer(s) for this stratum
    nout_layers <- mle + length(probs)
    k <- 1
    if (mle) {
      names(rres)[1] <- sprintf("%s_mle", names(rcounts)[iband])
      k <- 2
    }
    if (length(probs) > 0) {
      names(rres)[k:nout_layers] <- sprintf("%s_q_%g", names(rcounts)[iband], probs)
    }

    rres
  })

  # Merge list of result layers into a single SpatRaster
  # and return
  terra::rast(res)
}


#' Calculate quantiles for change in vegetation cover between two times
#'
#' This function uses the same approach for Bayesian estimation of vegetation
#' cover as described for function \code{\link{get_cover_quantiles}}, but
#' applied to two rasters representing LiDAR point counts for the same area at
#' two different times. It returns a raster where the values in each band are
#' selected quantiles of the change in vegetation cover between time 1 and time
#' 2. The default is to calculate the median and the central 90\% bounds (i.e.
#' 5\%, 50\% and 95\% quantiles) for cover change in each stratum. Each input
#' raster should have two or more bands, with the first band representing ground
#' point counts and subsequent bands representing point counts for vegetation
#' strata arranged in increasing height order (i.e. ground is band 1).
#'
#' As described for function \code{\link{get_cover_quantiles}}, the estimation
#' of stratum vegetation cover is based on treating the discrete LiDAR returns
#' as a binomial sampling process, where the probability of a return from
#' vegetation in the stratum being considered corresponds to vegetation cover.
#' Under this model, the distribution of possible cover values that could have
#' generated the observed point counts for a pixel will follow a beta
#' distribution. Change in vegetation cover can therefore be estimated by taking
#' the distribution of differences between the beta distribution for time 2
#' minus that for time 1.
#'
#' @param rcounts0 Point counts raster for the first (earlier) time. Normally,
#'   this will be a \code{terra} package \code{SpatRaster} object generated by
#'   function \code{get_stratum_counts()}, but it may also be a
#'   \code{RasterStack} or \code{RasterBrick} (\code{raster} package) object.
#'   \strong{Important:} the bands must be arranged in increasing height order,
#'   i.e. ground layer, then understorey layer(s), then overstorey layer(s).
#'
#' @param rcounts1 Point counts raster for the second (later) time. This must
#'   have the same dimensions (rows, columns and number of bands) as
#'   \code{rcounts0}. Generally it will also have the same spatial bounds, but
#'   this is not checked to allow the function to be used for other types of
#'   comparisons (e.g. space for time substitution).
#'
#' @param probs A numeric vector of one or more probability values specifying
#'   the quantiles of vegetation cover change to calculate.  The default
#'   \code{c(0.05, 0.5, 0.95)} returns quantiles for the median and the central
#'   90\% interval of cover change.
#'
#' @param backgroundNA Controls what pixel value should be returned for a
#'   stratum when there are no LiDAR points for the stratum , any lower strata
#'   or ground level in one or both point counts rasters. If set to \code{TRUE},
#'   such cases will have missing (\code{NA}) pixel values for all quantiles for
#'   the stratum. If \code{FALSE} (the default), quantiles for change values
#'   will be based on the prior beta distribution.
#'
#' @param beta_prior (\strong{Expert use only!}) Either a numeric vector
#'   of two values defining the prior beta distribution to use for all strata,
#'   or a named list of two-element numeric vectors where the element names
#'   match (case-insensitive) layer names for vegetation strata in the input
#'   point count raster. The default is \code{c(1,1)} for a \code{beta(1,1)}
#'   distribution which is equivalent to a uniform distribution on the (0,1)
#'   interval for all strata. This is probably what you want unless (a) you
#'   really know what you are doing and (b) there are particular reasons, i.e.
#'   previous studies or expert knowledge, to expect cover values for one or
#'   more strata to follow alternative distributions. See the Details section
#'   of function \code{get_cover_quantiles) for further explanation.
#'
#' @return A \code{SpatRast} (\code{terra} package) raster object with a layer
#'   for each requested quantile of vegetation cover change within each stratum.
#'   For example, calculating the default median plus 90\% bounds (0.05 and 0.95
#'   quantiles) of cover change for 5 vegetation strata would return a raster
#'   object with 15 layers. Layers are arranged by stratum, then by quantile.
#'   Layer names have the form \code{stratum_dq_prob}, e.g.
#'   \code{'TallShrub_dq_0.5'} for the median (50\%) quantile of cover change.
#'
#'
#' @export
#'
get_cover_difference <- function(rcounts0,
                                 rcounts1,
                                 probs = c(0.05, 0.5, 0.95),
                                 backgroundNA = FALSE,
                                 beta_prior = c(1, 1)) {

  rcounts0 <- .as_spat_raster(rcounts0)
  .sanity_check_point_counts(rcounts0)

  rcounts1 <- .as_spat_raster(rcounts1)
  .sanity_check_point_counts(rcounts1)

  if (!is.numeric(probs)) stop("Argument probs should be a numeric vector or NULL")
  if (!all(probs > 0 & probs < 1)) stop("Requested quantile (probs) must all be >0 and <1")

  probs <- sort(unique(probs))

  backgroundNA <- .as_boolean(backgroundNA)

  nbands <- terra::nlyr(rcounts0)
  if (nbands < 2) {
    msg <- glue::glue("Both point count rasters must have at least two layers
                       with the first layer being ground level point counts and
                       subsequent layers being stratum point counts in order of
                       increasing height.")

    stop(msg)
  }

  if (terra::nlyr(rcounts1) != nbands) {
    stop("Both point count rasters must have the same number of bands")
  }

  if (terra::ncol(rcounts0) != terra::ncol(rcounts1) ||
      terra::nrow(rcounts0) != terra::nrow(rcounts1)) {
    stop("Both point count rasters must have the same number of rows and columns")
  }

  # Check the beta_prior argument
  .sanity_check_beta_prior(beta_prior, nbands)

  # Convert the beta_prior argument to matrix form.
  if (is.numeric(beta_prior)) {
    beta_prior <- lapply(2:nbands, function(...) beta_prior)
  }
  beta_prior <- do.call(rbind, beta_prior)

  # Worker function for cover calculations.
  # Expects input raster 'x' to have four bands in order:
  #   s0, n0, s1, n1
  # where s_ is stratum points and n_ is total points.
  #
  fn <- function(x, istratum) {
    prior_params <- beta_prior[istratum, ]

    qdiffbeta(probs,
              s0 = x[1], n0 = x[2], s1 = x[3], n1 = x[4],
              beta_prior = beta_prior[istratum, ])
  }

  # Initialize a raster of total point counts with the ground layer
  # for each time
  rsum0 <- terra::subset(rcounts0, 1)
  rsum1 <- terra::subset(rcounts1, 1)

  # For each veg stratum band:
  #   - increment total point count
  #   - call worker function to calculate quantiles and/or MLE
  #
  res <- lapply(2:nbands, function(iband) {
    rband0 <- terra::subset(rcounts0, iband)
    rband1 <- terra::subset(rcounts1, iband)

    rsum0 <<- rsum0 + rband0
    rsum1 <<- rsum1 + rband1

    rres <- terra::app(c(rband0, rsum0, rband1, rsum1), fn, istratum=iband-1)

    # Set names for result layer(s) for this stratum
    if (length(probs) > 0) {
      names(rres) <- sprintf("%s_dq_%g", names(rcounts0)[iband], probs)
    }

    rres
  })

  # Merge list of result layers into a single SpatRaster
  # and return
  terra::rast(res)
}


# Private helper function to calculate the density of differences between two
# independent beta distributions.
#
# The differences are computed as f1 - f0 where f0 is beta(a0, b0) and f1 is
# beta(a1, b1). f0 parameters are based on counts s0 (successes) and n0 (total),
# while f1 parameters are based on counts s1 and n1. Both distributions use the
# same beta_prior parameters.
#
#
ddiffbeta <- function(x, s0, n0, s1, n1, beta_prior = c(1,1)) {
  a0 <- s0 + beta_prior[1]
  b0 <- n0 - s0 + beta_prior[2]

  a1 <- s1 + beta_prior[1]
  b1 <- n1 - s1 + beta_prior[2]

  A <- beta(a0, b0)*beta(a1, b1)

  dx <- sapply(x, function(xi) {
    if (xi < -1 || xi > 1) {
      NA

    } else if(xi > 0) {
      beta(a1, b0) * xi^(b0+b1-1) * (1 - xi)^(a1+b0-1) *
        .F1(b0, a0 + a1 + b0 + b1 - 2, 1 - a0, b0 + a1, 1 - xi, 1 - xi^2)

    } else if (xi < 0) {
      beta(a0, b1) * (-xi)^(b0+b1-1) * (1 + xi)^(a0+b1-1) *
        .F1(b1, 1 - a1, a0 + a1 + b0 + b1 - 2, a0 + b1, 1 - xi^2, 1 + xi)

    } else {
      beta(a0 + a1 - 1, b0 + b1 - 1)
    }
  })

  dx / A
}


# Private helper function to calculate probability distribution of differences
# between two independent beta distributions.
#
# The differences are computed as f1 - f0 where f0 is beta(a0, b0) and f1 is
# beta(a1, b1). f0 parameters are based on counts s0 (successes) and n0 (total),
# while f1 parameters are based on counts s1 and n1. Both distributions use the
# same beta_prior parameters.
#
pdiffbeta <- function(x, s0, n0, s1, n1, beta_prior = c(1,1)) {
  sapply(x, function(xi) integrate(ddiffbeta, -1, xi,
                                   s0=s0, n0=n0, s1=s1, n1=n1, beta_prior=beta_prior)$value)
}


# Private helper function to calculate quantiles of differences between two
# independent beta distributions.
#
# The differences are computed as f1 - f0 where f0 is beta(a0, b0) and f1 is
# beta(a1, b1). f0 parameters are based on counts s0 (successes) and n0 (total),
# while f1 parameters are based on counts s1 and n1. Both distributions use the
# same beta_prior parameters.
#
qdiffbeta <- function(p, s0, n0, s1, n1, beta_prior = c(1,1)) {
  fn <- function(x, px) abs(px - pdiffbeta(x, s0, n0, s1, n1, beta_prior))

  res <- sapply(p, function(pi) {
    optim(0, fn, pi = pi, method = "Brent", lower = -1, upper = 1)$par
  })

  res
}


# Private helper to calculate Appell F1 function.
#
# Used by function ddiffbeta.
#
# Note: all args MUST be length 1 but this is not checked
#
.F1 <- function(a, b1, b2, c, z1, z2) {
  fn <- function(u) {
    u^(a-1) * (1-u)^(c-a-1) * (1-u*z1)^(-b1) * (1-u*z2)^(-b2)
  }

  intg <- integrate(fn, 0, 1)$value
  gamma(c) / (gamma(a) * gamma(c - a)) * intg
}



# Private helper to check that a raster looks like valid point count data.
# Input must be a terra::SpatRaster object.
#
.sanity_check_point_counts <- function(r, label = NULL) {
  if (is.null(label)) label <- deparse(substitute(r))

  if (!inherits(r, "SpatRaster")) stop(label, " must be a terra package SpatRaster object")

  if (!all(terra::hasMinMax(r))) terra::setMinMax(r)
  lims <- t( terra::minmax(r) ) # bands as rows; min,max as cols

  # Check sane minimum values
  if (any(lims[,1] < 0)) stop(label, " has minimum value less than zero in one or more bands")

  # Check values are integers
  x <- as.vector(lims)
  if (any(x - as.integer(x) != 0)) stop(label, " has non-integer values in one or more bands")
}


# Private helper function to check that a vector is a valid set of parameters
# for a beta prior distribution.
#
# x - numeric vector or list of number vectors
# nlayers - number of layers in the point counts raster being processed
#   by get_cover_quantiles()
#
.sanity_check_beta_prior <- function(x, nlayers) {
  nm <- deparse(substitute(x))

  .check_vector <- function(v, index = NULL) {
    if (!is.null(index)) nm <- paste(nm, "element", index)
    if (length(v) != 2) stop(nm, " should be a numeric vector with two values")
    if (!all(v > 0)) stop("Both values in ", nm, " must be greater than zero")
  }

  if (is.numeric(x)) {
    .check_vector(x)

  } else if (is.list(x)) {
    if (length(x) != nlayers - 1) {
      msg <- glue::glue(
        "The list of beta prior parameters '{nm}' has {length(x)} elements.
        Expected {nlayers - 1} elements corresponding to the {nlayers - 1} non-ground layers
        in the point counts raster")
      stop(msg)
    }

    for (i in seq_along(x)) .check_vector(x[[i]], i)

  } else {
    stop(nm, " must be a two-element numeric vector or a list of vectors")
  }
}

